{"docstore/data": {"6cfdf715-672a-4759-86bc-2c56ab443164": {"__data__": {"id_": "6cfdf715-672a-4759-86bc-2c56ab443164", "embedding": null, "metadata": {"filename": "ChessEngine.py", "extension": ".py", "file_path": "..\\database\\ChessEngine.py", "file_name": "ChessEngine.py", "file_type": "text/x-python", "file_size": 11140, "creation_date": "2024-07-20", "last_modified_date": "2025-04-06"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "565fff3b-b80f-4bf1-b4f4-336f70e972de", "node_type": "4", "metadata": {"filename": "ChessEngine.py", "extension": ".py", "file_path": "..\\database\\ChessEngine.py", "file_name": "ChessEngine.py", "file_type": "text/x-python", "file_size": 11140, "creation_date": "2024-07-20", "last_modified_date": "2025-04-06"}, "hash": "b7567abff675fa3ec9e47ab4ec07a8fd90afe29ea87552233a78cc35e01f4fe0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f795e87d-cb35-4cbd-ad10-22d3dcead805", "node_type": "1", "metadata": {}, "hash": "bf66a1975588f4c60ed1a180e1138cc4d4dda2ada2bdefdc87c04e94d932d9dc", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "class GameState: \n        \n        def __init__(self):\n                self.board = [\n                        [\"bR\", \"bN\", \"bB\", \"bQ\", \"bK\", \"bB\", \"bN\", \"bR\"],\n                        [\"bp\", \"bp\", \"bp\", \"bp\", \"bp\", \"bp\", \"bp\", \"bp\"],\n                        [\"--\", \"--\", \"--\", \"--\", \"--\", \"--\", \"--\", \"--\"],\n                        [\"--\", \"--\", \"--\", \"--\", \"--\", \"--\", \"--\", \"--\"],\n                        [\"--\", \"--\", \"--\", \"--\", \"--\", \"--\", \"--\", \"--\"],\n                        [\"--\", \"--\", \"--\", \"--\", \"--\", \"--\", \"--\", \"--\"],\n                        [\"wp\", \"wp\", \"wp\", \"wp\", \"wp\", \"wp\", \"wp\", \"wp\"],\n                        [\"wR\", \"wN\", \"wB\", \"wQ\", \"wK\", \"wB\", \"wN\", \"wR\"]]\n                self.moveFunctions = {'p': self.getPawnMoves, 'R': self.getRookMoves, 'N': self.getKnightMoves,\n                                      'B': self.getBishopMoves, 'Q': self.getQueenMoves, 'K': self.getKingMoves}\n                self.whiteToMove = True,\n                self.moveLog = []\n                self.whiteKingLocation = (7, 4)\n                self.blackKingLocation = (0, 4)\n                self.checkMate = False\n                self.staleMate = False\n\n        def makeMove(self, move):\n                self.board[move.startRow][move.startCol] = \"--\"\n                self.board[move.endRow][move.endCol] = move.pieceMoved\n                self.moveLog.append(move)\n                self.whiteToMove = not self.whiteToMove\n                if move.pieceMoved == \"wK\":\n                        self.whiteKingLocation = (move.endRow, move.endCol)\n                elif move.pieceMoved == \"bK\":\n                        self.blackKingLocation = (move.endRow, move.endCol)\n\n                if move.isPawnPromotion:\n                        self.board[move.endRow][move.endCol] = move.pieceMoved[0] + \"Q\"\n\n\n        def undoMove(self):\n                if len(self.moveLog) != 0:\n                        move = self.moveLog.pop()\n                        self.board[move.startRow][move.startCol] = move.pieceMoved\n                        self.board[move.endRow][move.endCol] = move.pieceCaptured\n                        self.whiteToMove = not self.whiteToMove\n                        if move.pieceMoved == \"wK\":\n                                self.whiteKingLocation = (move.startRow, move.startCol)\n                        if move.pieceMoved == \"bK\":\n                                self.blackKingLocation = (move.startRow, move.startCol)\n        \"\"\"\n        All move considering checks\n        \"\"\"\n        def getValidMoves(self):\n                moves = self.getAllPossibleMoves()\n                for i in range(len(moves)-1, -1, -1):\n                        self.makeMove(moves[i])\n                        self.whiteToMove = not self.whiteToMove\n                        if self.inCheck():\n                                moves.remove(moves[i])\n                        self.whiteToMove = not self.whiteToMove\n                        self.undoMove()\n                if len(moves) == 0:\n                        if self.inCheck():\n                                self.checkMate = True\n                        else:\n                                self.staleMate = True\n                else:\n                        self.checkMate = False\n                        self.staleMate = False\n\n                return moves \n\n        def inCheck(self):\n                if self.whiteToMove:\n                        return self.squareUnderAttack(self.whiteKingLocation[0], self.whiteKingLocation[1])\n                else:\n                        return self.squareUnderAttack(self.blackKingLocation[0], self.blackKingLocation[1])\n\n        def squareUnderAttack(self, r, c):\n                self.whiteToMove = not self.whiteToMove\n                oppMoves = self.getAllPossibleMoves()\n                self.whiteToMove  = not self.whiteToMove\n                for move in oppMoves:\n                        if move.endRow == r and move.endCol == c:\n                                return True\n                return False\n\n\n\n\n        \"\"\"\n        All move without considering checks\n        \"\"\"\n        def getAllPossibleMoves(self):\n                moves = []\n                for r in range(len(self.board)):\n                        for c in range(len(self.board[r])):\n                                turn = self.board[r][c][0] # b or w based on turn\n                                if(turn == 'w' and self.whiteToMove) or (turn == 'b' and not self.whiteToMove):\n                                        piece = self.board[r][c][1]\n                                        self.moveFunctions[piece](r,c, moves)\n                return moves", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4606, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f795e87d-cb35-4cbd-ad10-22d3dcead805": {"__data__": {"id_": "f795e87d-cb35-4cbd-ad10-22d3dcead805", "embedding": null, "metadata": {"filename": "ChessEngine.py", "extension": ".py", "file_path": "..\\database\\ChessEngine.py", "file_name": "ChessEngine.py", "file_type": "text/x-python", "file_size": 11140, "creation_date": "2024-07-20", "last_modified_date": "2025-04-06"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "565fff3b-b80f-4bf1-b4f4-336f70e972de", "node_type": "4", "metadata": {"filename": "ChessEngine.py", "extension": ".py", "file_path": "..\\database\\ChessEngine.py", "file_name": "ChessEngine.py", "file_type": "text/x-python", "file_size": 11140, "creation_date": "2024-07-20", "last_modified_date": "2025-04-06"}, "hash": "b7567abff675fa3ec9e47ab4ec07a8fd90afe29ea87552233a78cc35e01f4fe0", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6cfdf715-672a-4759-86bc-2c56ab443164", "node_type": "1", "metadata": {"filename": "ChessEngine.py", "extension": ".py", "file_path": "..\\database\\ChessEngine.py", "file_name": "ChessEngine.py", "file_type": "text/x-python", "file_size": 11140, "creation_date": "2024-07-20", "last_modified_date": "2025-04-06"}, "hash": "bff7353a7592680eea7ac2c41c899a7a8e1866a6eed0d5898c2be74b407effd2", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\"\"\"\n        All move without considering checks\n        \"\"\"\n        def getAllPossibleMoves(self):\n                moves = []\n                for r in range(len(self.board)):\n                        for c in range(len(self.board[r])):\n                                turn = self.board[r][c][0] # b or w based on turn\n                                if(turn == 'w' and self.whiteToMove) or (turn == 'b' and not self.whiteToMove):\n                                        piece = self.board[r][c][1]\n                                        self.moveFunctions[piece](r,c, moves)\n                return moves\n\n\n        def getPawnMoves(self, r, c, moves):\n                if self.whiteToMove:\n                        if self.board[r-1][c] == \"--\":\n                                moves.append(Move((r, c),(r-1, c), self.board))\n                                if r == 6 and self.board[r-2][c] == \"--\":\n                                        moves.append(Move((r, c),(r-2, c), self.board))\n                        if c-1 >= 0:\n                                if self.board[r-1][c-1][0] == 'b':\n                                        moves.append(Move((r, c),(r-1, c-1), self.board))\n                        if c+1 <= 7:\n                                if self.board[r-1][c+1][0] == 'b':\n                                        moves.append(Move((r, c),(r-1, c+1), self.board))\n                \n                else:\n                        if self.board[r+1][c] == \"--\":\n                                moves.append(Move((r, c),(r+1, c), self.board))\n                                if r == 1 and self.board[r+2][c] == \"--\":\n                                        moves.append(Move((r, c),(r+2, c), self.board))\n                        if c-1 >= 0:\n                                if self.board[r+1][c-1][0] == 'w':\n                                        moves.append(Move((r, c),(r+1, c-1), self.board))\n                        if c+1 <= 7:\n                                if self.board[r+1][c+1][0] == 'w':\n                                        moves.append(Move((r, c),(r+1, c+1), self.board))\n\n        def getRookMoves(self, r, c, moves):\n                directions = ((-1, 0), (0, -1), (1, 0), (0, 1))\n                enemyColor = \"b\" if self.whiteToMove else \"w\"\n                for d in directions:\n                        for i in range(1, 8):\n                                endRow = r + d[0] * i\n                                endCol = c + d[1] * i\n                                if 0 <= endRow < 8 and 0 <= endCol < 8:\n                                        endPiece = self.board[endRow][endCol]\n                                        if endPiece == \"--\":\n                                                moves.append(Move((r,c), (endRow, endCol), self.board))\n                                        elif endPiece[0] == enemyColor:\n                                                moves.append(Move((r,c), (endRow, endCol), self.board))\n                                                break\n                                        else:\n                                                break\n                                else:\n                                        break\n\n        def getKnightMoves(self, r,c,moves):\n                knightMoves = ((-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2,1))\n                allyColor = \"w\" if self.whiteToMove else \"b\"\n                for m in knightMoves:\n                        endRow = r + m[0]\n                        endCol = c + m[1]\n                        if 0 <= endRow < 8 and 0 <= endCol < 8:\n                                endPiece = self.board[endRow][endCol]\n                                if endPiece[0] != allyColor:\n                                        moves.append(Move((r,c), (endRow, endCol), self.board))\n\n        def getBishopMoves(self, r,c,moves):\n                directions = ((-1, -1), (-1, 1), (1, -1), (1, 1))\n                enemyColor = \"b\" if self.whiteToMove else \"w\"\n                for d in directions:\n                        for i in range(1, 8):\n                                endRow = r + d[0] * i\n                                endCol = c + d[1] * i\n                                if 0 <= endRow < 8 and 0 <= endCol < 8:\n                                        endPiece = self.board[endRow][endCol]\n                                        if endPiece == \"--\":\n                                                moves.append(Move((r,c), (endRow, endCol), self.board))\n                                        elif endPiece[0] == enemyColor:\n                                                moves.append(Move((r,c), (endRow, endCol), self.board))\n                                                break\n                                        else:\n                                                break\n                                else:\n                                        break\n\n        def getQueenMoves(self, r,c,moves):\n                self.getRookMoves(r, c, moves)\n                self.getBishopMoves(r, c, moves)\n\n        def getKingMoves(self, r,c,moves):\n                kingMoves = ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1,1) )\n                allyColor = \"w\" if self.whiteToMove else \"b\"\n                for i in range(8):\n                        endRow = r + kingMoves[i][0]\n                        endCol = c + kingMoves[i][1]\n                        if 0 <= endRow < 8 and 0 <= endCol < 8:\n                                endPiece = self.board[endRow][endCol]\n                                if endPiece[0] != allyColor:\n                                        moves.append(Move((r,c), (endRow, endCol), self.board))\nclass Move():\n\n        ranksToRow = {\"1\": 7, \"2\": 6, \"3\": 5, \"4\": 4,\n                      \"5\": 3, \"6\": 2, \"7\": 1, \"8\": 0}\n        rowsToRanks = {v: k for k, v in ranksToRow.items()}\n        filesToCols = {\"a\": 0, \"b\": 1, \"c\": 2, \"d\": 3,\n                      \"e\": 4, \"f\": 5, \"g\": 6, \"h\": 7}\n        colsToFiles = {v: k for k, v in filesToCols.items()}\n\n        def __init__(self, startSq, endSq, board):\n                self.startRow = startSq[0]\n                self.startCol = startSq[1]\n                self.endRow = endSq[0] \n                self.endCol = endSq[1]\n                self.pieceMoved = board[self.startRow][self.startCol]\n                self.pieceCaptured = board[self.endRow][self.endCol]\n                self.isPawnPromotion = False\n                if (self.pieceMoved == 'wp' and self.endRow == 0) or (self.pieceMoved == 'bp' and self.endRow == 7):\n                        self.isPawnPromotion = True\n                self.moveID = self.startRow * 1000 + self.startCol * 100 + self.endRow * 10 + self.endCol\n\n        def __eq__(self, other):\n                if isinstance(other, Move):\n                        return self.moveID  == other.moveID\n                return False\n\n\n        def getChessNotation(self):\n                return self.getRankFile(self.startRow, self.startCol) + self.getRankFile(self.endRow, self.endCol)\n\n        def getRankFile(self, r, c):\n                return  self.colsToFiles[c] + self.rowsToRanks[r]", "mimetype": "text/plain", "start_char_idx": 4003, "end_char_idx": 11137, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/metadata": {"6cfdf715-672a-4759-86bc-2c56ab443164": {"doc_hash": "bff7353a7592680eea7ac2c41c899a7a8e1866a6eed0d5898c2be74b407effd2", "ref_doc_id": "565fff3b-b80f-4bf1-b4f4-336f70e972de"}, "f795e87d-cb35-4cbd-ad10-22d3dcead805": {"doc_hash": "9038ba07de71a4e98013a1bd46282a4ad1579a2991af52215cc7056b1481be62", "ref_doc_id": "565fff3b-b80f-4bf1-b4f4-336f70e972de"}}, "docstore/ref_doc_info": {"565fff3b-b80f-4bf1-b4f4-336f70e972de": {"node_ids": ["6cfdf715-672a-4759-86bc-2c56ab443164", "f795e87d-cb35-4cbd-ad10-22d3dcead805"], "metadata": {"filename": "ChessEngine.py", "extension": ".py", "file_path": "..\\database\\ChessEngine.py", "file_name": "ChessEngine.py", "file_type": "text/x-python", "file_size": 11140, "creation_date": "2024-07-20", "last_modified_date": "2025-04-06"}}}}